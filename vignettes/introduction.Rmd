%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{introduction to kfigr}

```{r setup, echo=FALSE, message=FALSE}
require(knitr)
require(kfigr)
opts_chunk$set(message=FALSE, warning=FALSE)
```

Introducing kfigr: a streamlined, knitr-integrated version of figr
------------------------------------------------------------------

### Why kfigr? ###

The `kfigr` package was developed shortly after completion of `figr` version 1. During the development phase of `figr` it became apparent that anchoring and cross-referencing in knitr markdown documents could be simplified with minimal loss of useability by limiting anchoring and cross-referencing to  knitr chunks. The advantages of this approach are

1. Special code for placing figures and tables is no longer needed, reducing usage to just one function and one code chunk option. Any chunk can be anchored regardless of the output.
2. The labels used to reference objects now correspond to chunk labels, which makes it less likely for referencing mistakes to occur.
3. Cross-referencing is separated from captions. Captioning functionality is no longer provided, but users can specify their own hooks for adding captions. The package `kexfig` is under development and will provide a figure captioning hook along with a way to place external files (e.g. images) while taking advantage of knitr chunk options.
4. Defining anchors as a chunk option improve document readability by forcing users to write distinct chunks for any referenced output. For example, if you want to refer to both a figure and the code used to create the figure you must write the example code and generate the figure in separate chunks. This forced structuring at the source level makes it easier for readers to compare a document to the code used to generate said document.
5. Users have complete flexibility to define numbering groups for distinguishing between e.g. figures and tables.
6. Global options for `kfigr` are defined as new `knitr` options, rather than existing as a separate entity.

### How does it work? ###

It's very simple! `kfigr` defines a custom hook, `anchor`, which `kfigr` uses to decide how to track the chunk. We refer to an anchored chunk as a "figr", and every figr has a distinct type. For instance, if a user wants to create a figure to refer to later, they might pass `anchor="figure"`. This tells `figr` that the current chunk is a special kind of chunk of type "figure" that needs to be anchored in the document. `kfigr` uses the chunk label to generate an HTML anchor tag above the chunk and assigns a number to the chunk based on its type. As an example, consider the following chunk. 

```{r first, anchor="figure"}
require(ggplot2)
qplot(rnorm(100), geom="histogram")
```

I named the chunk "first" and used the chunk option `anchor="figure"`. Now, I will use the function `figr('first')` in an inline chunk to reference the chunk here: `r figr('first')`. `figr` returns the number of the referenced chunk as a markdown link, e.g. `[1](#first)`. `kfigr` keeps track of reference numbers by tracking the chunk placement sequence separately for each figr type.  Note that the value of the `anchor` option is case sensitive, so "Figure" is different from "figure".

Like the `figr` package, you can reference a chunk before you actually define it. You must specify the `type` of figr when referencing a later chunk, and it is up to you to ensure every chunk you reference is defined. Furthermore, if you want to refer to a later chunk you must first reference intervening chunks. This can be done inline using `invisible(figr(label))`. This limitation is due to the way markdown documents are rendered; if you need smarter referencing capabilities, consider using LaTeX instead of markdown.

You can pass `prefix=TRUE` or change the [global options](#setting-global-options) to get a full label, e.g. `r figr('second', TRUE, type="figure")`.

```{r second, anchor="figure"}
qplot(runif(100), geom="density")
```

The method of anchoring and referencing a chunk is not affected by chunk options or output, as shown in `r figr('third', TRUE, type="table")`:

```{r third, anchor="table", results='asis'}
kable(head(iris, 6))
```

Anchoring even works for chunks that use the `ref.label` option. For instance, consider the following code:

```{r fourth, eval=FALSE}
x = 1:20
y = x + rnorm(20)
lm(y~x)
```

I have not anchored the above chunk and the code was not evaluated because I used the chunk option `eval=FALSE`. If I had used `echo=FALSE` you would have no idea that the chunk even existed! But I can reproduce the chunk by creating an empty chunk with the same name (see the `knitr` documentation for more details) and anchor the empty chunk, as shown in `r figr('fourth', TRUE, type="block")`. 

```{r fourth, anchor="block"}
```

If you want to reference both the code and the figure separately you can use the chunk option `ref.label` and specify an anchor for each referring chunk. Below, I create a hidden chunk and reference it using eval=FALSE to produce the code block. I then reference the hidden chunk a second time using echo=FALSE to produce only the output. 

```{r fifth, echo=FALSE, eval=FALSE}
df <- data.frame(x=x, y=y)
ggplot(df, aes(x=x, y=y)) + geom_smooth(method="lm") + 
geom_point(pch=21, color="black", fill="red")
```

```{r fifth-code, ref.label='fifth', anchor="block", eval=FALSE}
```

```{r fifth-plot, ref.label='fifth', anchor="figure", echo=FALSE}
```

You can verify that `r figr('fifth-code', TRUE)` and `r figr('fifth-plot', TRUE)` are distinct.

`kfigr` tracks figrs internally. If you want to get a list of indexed figrs, you can use `anchors()` to return a structure that lists the labels by figr type, a reference history, and an index, as shown in `r figr('anchors-def', TRUE, type="block")`. The `history` attribute can be helpful for troubleshooting problems with document references.

```{r anchors-def, anchor="block"}
str(anchors())
```

<a name="setting-global-options"></a>
### Setting global options ###

`kfigr` uses knitr_opts to maintain global default settings. `kfigr` option names are identified by the prefix "kfigr", such as `kfigr.link` (to display a link to the anchor in citations) or `kfigr.prefix` to include the prefix when referencing. These options can be changed using `opts_knit$get` and `opts_knit$set`. Any global options set within a chunk will not be available in that particular chunk (see the `knitr` documentation for more details). 

### A note on Tangling ###
An important limitation of tangle is that inline code chunks are not evaluated. Under most circumstances the tangled code should produce the same figr numbers as the knitted document, but discrepancies will appear if you have forgotten to invisibly reference intermediate chunks, or have anchored junks in a different order than referenced. Tangling your code is one way to check that your references are ordered correctly.
